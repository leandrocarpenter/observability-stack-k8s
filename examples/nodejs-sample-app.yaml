apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-nodejs-app
  namespace: observability
  labels:
    app: sample-nodejs-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: sample-nodejs-app
  template:
    metadata:
      labels:
        app: sample-nodejs-app
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "3000"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: nodejs-app
        image: node:18-alpine
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: APP_NAME
          value: "sample-nodejs-app"
        command: ["/bin/sh"]
        args:
          - -c
          - |
            echo 'const express = require("express");
            const promClient = require("prom-client");
            
            const app = express();
            const port = 3000;
            
            // Configurar métricas Prometheus
            const collectDefaultMetrics = promClient.collectDefaultMetrics;
            collectDefaultMetrics({ timeout: 5000 });
            
            const httpRequestsTotal = new promClient.Counter({
              name: "http_requests_total",
              help: "Total HTTP requests",
              labelNames: ["method", "route", "status_code"]
            });
            
            const httpRequestDuration = new promClient.Histogram({
              name: "http_request_duration_seconds",
              help: "HTTP request duration in seconds",
              labelNames: ["method", "route"]
            });
            
            // Middleware para métricas
            app.use((req, res, next) => {
              const start = Date.now();
              
              res.on("finish", () => {
                const duration = (Date.now() - start) / 1000;
                httpRequestsTotal.inc({
                  method: req.method,
                  route: req.route?.path || req.path,
                  status_code: res.statusCode
                });
                httpRequestDuration.observe({
                  method: req.method,
                  route: req.route?.path || req.path
                }, duration);
              });
              
              next();
            });
            
            // Rotas
            app.get("/", (req, res) => {
              res.json({ message: "Hello from Node.js observability demo!", timestamp: new Date() });
            });
            
            app.get("/health", (req, res) => {
              res.json({ status: "healthy", uptime: process.uptime() });
            });
            
            app.get("/metrics", (req, res) => {
              res.set("Content-Type", promClient.register.contentType);
              res.end(promClient.register.metrics());
            });
            
            // Rota que simula erro ocasional
            app.get("/random", (req, res) => {
              if (Math.random() < 0.1) {
                res.status(500).json({ error: "Random error occurred" });
              } else {
                res.json({ random: Math.random(), timestamp: new Date() });
              }
            });
            
            app.listen(port, () => {
              console.log(`App running on port ${port}`);
            });' > /tmp/app.js
            
            cd /tmp
            npm init -y
            npm install express prom-client
            node app.js
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
---
apiVersion: v1
kind: Service
metadata:
  name: sample-nodejs-app-service
  namespace: observability
  labels:
    app: sample-nodejs-app
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "3000"
    prometheus.io/path: "/metrics"
spec:
  selector:
    app: sample-nodejs-app
  ports:
  - protocol: TCP
    port: 3000
    targetPort: 3000
    name: http
  type: ClusterIP